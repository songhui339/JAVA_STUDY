package com.kh.algorithm.practice;
/*
 * 이소희 담당
 * 버블 정렬
 * 
 *  - 인접한 두 항목의 값를 비교하여 크기 순서대로 서로의 값을 교환하는 정렬 방식. 
 *  - 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 '버블 정렬'이라는 이름을 갖게 된다.
 *  - 단순하여 구현하기 쉬운 코드라는 장점이 있으나 단점인 느린 속도로 효율성이 떨어진다. 
 *  - 배열의 길이을 n개로 볼 때 
 *    버블 정렬은 n-1, n-2, n-3 ...번을 반복하는 정렬로 n(n-1)/2번 반복하며
 *    O(n²)의 시간 복잡도를 갖는다. 
 *    
 *  
 *  (정렬 과정 예시)
 *  해당 배열을 오름 차순으로 정렬하는 과정.
 *  int[] num = {8,3,6,1,5};
 *  
 *  1회전) 8과 3을 비교하여 교환 {3,8,6,1,5}, 8과 6을 비교하여 교환 {3,6,8,1,5},
 *  	  8과 1을 비교하여 교환 {3,6,1,8,5}, 8과 5를 비교하여 교환 {3,6,1,5,8}
 *  -> 1회전 결과 {3,6,1,5,8} 
 *     1회전을 하게 되면 가장 큰 값이 맨 뒤로 이동하게 된다. 
 *     i번째 회전 시 (n-i)번째 인덱스 까지 정렬한다.
 *  	
 *  
 *  2회전) 6과 1을 비교하여 교환 {3,1,6,5,8}, 6과 5를 비교하여 교환 {3,1,5,6,8}
 *  -> 2회전 결과 {3,1,5,6,8}
 *     2회전 시 5-2 즉 3번째 인덱스 까지 정렬하게 된다. 
 *     
 *  
 *  3회전) 3과 1을 비교하여 교환 {1,3,5,6,8}
 *  -> 3회전 결과 {1,3,5,6,8}
 */
public class B_Bubble_SH {
	
	public void bubble1() {
		int num[] = {8,3,6,1,5};
		
		for (int i = 0; i < num.length; i++) {
			for (int j = 0; j < num.length -i - 1; j++) {
				if(num[j] > num[j+1]) {
					int tmp = num[j];
					num[j] = num[j+1];
					num[j+1] = tmp;	
				}
			}
		}
		
		for (int i = 0; i < num.length; i++) {
			System.out.printf("%d ", num[i]);
		}
	}
}
